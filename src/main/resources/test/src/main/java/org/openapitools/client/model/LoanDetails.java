/*
 * Lendismart API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents the loan details of an Application
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-23T19:03:15.118012600+02:00[Europe/Madrid]", comments = "Generator version: 7.9.0")
public class LoanDetails {
  public static final String SERIALIZED_NAME_REQUESTED_AMOUNT = "requestedAmount";
  @SerializedName(SERIALIZED_NAME_REQUESTED_AMOUNT)
  private String requestedAmount;

  public static final String SERIALIZED_NAME_MAX_MONTHLY_PAYMENT = "maxMonthlyPayment";
  @SerializedName(SERIALIZED_NAME_MAX_MONTHLY_PAYMENT)
  private String maxMonthlyPayment;

  public static final String SERIALIZED_NAME_TERM = "term";
  @SerializedName(SERIALIZED_NAME_TERM)
  private Integer term;

  public static final String SERIALIZED_NAME_FINANCING_PROMOTION = "financingPromotion";
  @SerializedName(SERIALIZED_NAME_FINANCING_PROMOTION)
  private String financingPromotion;

  /**
   * The desired financial product type (e.g. interest-free, interest-bearing, etc.)
   */
  @JsonAdapter(ProductTypeEnum.Adapter.class)
  public enum ProductTypeEnum {
    INTEREST_BEARING("INTEREST_BEARING"),
    
    ZERO_INTEREST("ZERO_INTEREST"),
    
    SUBSIDIZED_INTEREST("SUBSIDIZED_INTEREST"),
    
    OPTION_PLUS("OPTION_PLUS"),
    
    MULTIOPTION("MULTIOPTION"),
    
    LEASING("LEASING"),
    
    REFINANCING("REFINANCING"),
    
    BULLET("BULLET"),
    
    LOAN("LOAN"),
    
    SUBSCRIPTION("SUBSCRIPTION"),
    
    VARIABLE_RATE("VARIABLE_RATE"),
    
    RENTING("RENTING"),
    
    PROMOTION("PROMOTION"),
    
    STANDARD("STANDARD"),
    
    BNPL("BNPL"),
    
    KIA_FLEXIBLE_RANGE_FINANCE("KIA_FLEXIBLE_RANGE_FINANCE"),
    
    KIA_KREDIT("KIA_KREDIT"),
    
    KIA_PROTECCION_CLIENTE("KIA_PROTECCION_CLIENTE"),
    
    KIA_FLEXIPLAN("KIA_FLEXIPLAN");

    private String value;

    ProductTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ProductTypeEnum fromValue(String value) {
      for (ProductTypeEnum b : ProductTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ProductTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ProductTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ProductTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ProductTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ProductTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PRODUCT_TYPE = "productType";
  @SerializedName(SERIALIZED_NAME_PRODUCT_TYPE)
  private ProductTypeEnum productType;

  public static final String SERIALIZED_NAME_OPENING_FEE_PCT = "openingFeePct";
  @SerializedName(SERIALIZED_NAME_OPENING_FEE_PCT)
  private String openingFeePct;

  public static final String SERIALIZED_NAME_MAX_NIR = "maxNir";
  @SerializedName(SERIALIZED_NAME_MAX_NIR)
  private String maxNir;

  /**
   * The preferred type of fee payment (if not zero)
   */
  @JsonAdapter(FeePaymentTypeEnum.Adapter.class)
  public enum FeePaymentTypeEnum {
    UPFRONT("UPFRONT"),
    
    FINANCED("FINANCED");

    private String value;

    FeePaymentTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FeePaymentTypeEnum fromValue(String value) {
      for (FeePaymentTypeEnum b : FeePaymentTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<FeePaymentTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FeePaymentTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FeePaymentTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return FeePaymentTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      FeePaymentTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_FEE_PAYMENT_TYPE = "feePaymentType";
  @SerializedName(SERIALIZED_NAME_FEE_PAYMENT_TYPE)
  private FeePaymentTypeEnum feePaymentType;

  public static final String SERIALIZED_NAME_GRACE_PERIOD = "gracePeriod";
  @SerializedName(SERIALIZED_NAME_GRACE_PERIOD)
  private Integer gracePeriod;

  public static final String SERIALIZED_NAME_MONTHLY_DUE_DATE = "monthlyDueDate";
  @SerializedName(SERIALIZED_NAME_MONTHLY_DUE_DATE)
  private Integer monthlyDueDate;

  public static final String SERIALIZED_NAME_INSURANCE = "insurance";
  @SerializedName(SERIALIZED_NAME_INSURANCE)
  private Boolean insurance;

  public static final String SERIALIZED_NAME_NO_ACCOUNT = "noAccount";
  @SerializedName(SERIALIZED_NAME_NO_ACCOUNT)
  private Boolean noAccount;

  /**
   * It indicates whether the applicant is an individual or a company
   */
  @JsonAdapter(ApplicantTypeEnum.Adapter.class)
  public enum ApplicantTypeEnum {
    PERSONAL("PERSONAL"),
    
    BUSINESS("BUSINESS"),
    
    CONDO_ASSOCIATION("CONDO_ASSOCIATION");

    private String value;

    ApplicantTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ApplicantTypeEnum fromValue(String value) {
      for (ApplicantTypeEnum b : ApplicantTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ApplicantTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ApplicantTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ApplicantTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ApplicantTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ApplicantTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_APPLICANT_TYPE = "applicantType";
  @SerializedName(SERIALIZED_NAME_APPLICANT_TYPE)
  private ApplicantTypeEnum applicantType;

  public static final String SERIALIZED_NAME_MAX_MERCHANT_COST = "maxMerchantCost";
  @SerializedName(SERIALIZED_NAME_MAX_MERCHANT_COST)
  private String maxMerchantCost;

  public static final String SERIALIZED_NAME_MAX_MERCHANT_COST_PCT = "maxMerchantCostPct";
  @SerializedName(SERIALIZED_NAME_MAX_MERCHANT_COST_PCT)
  private String maxMerchantCostPct;

  public LoanDetails() {
  }

  public LoanDetails requestedAmount(String requestedAmount) {
    this.requestedAmount = requestedAmount;
    return this;
  }

  /**
   * The amount of the loan, the value should be less than 100,000
   * @return requestedAmount
   */
  @javax.annotation.Nullable
  public String getRequestedAmount() {
    return requestedAmount;
  }

  public void setRequestedAmount(String requestedAmount) {
    this.requestedAmount = requestedAmount;
  }


  public LoanDetails maxMonthlyPayment(String maxMonthlyPayment) {
    this.maxMonthlyPayment = maxMonthlyPayment;
    return this;
  }

  /**
   * The maximum monthly instalment the applicant is willing to pay for the loan
   * @return maxMonthlyPayment
   */
  @javax.annotation.Nullable
  public String getMaxMonthlyPayment() {
    return maxMonthlyPayment;
  }

  public void setMaxMonthlyPayment(String maxMonthlyPayment) {
    this.maxMonthlyPayment = maxMonthlyPayment;
  }


  public LoanDetails term(Integer term) {
    this.term = term;
    return this;
  }

  /**
   * The desired number of terms in which the loan will be payed.
   * @return term
   */
  @javax.annotation.Nullable
  public Integer getTerm() {
    return term;
  }

  public void setTerm(Integer term) {
    this.term = term;
  }


  public LoanDetails financingPromotion(String financingPromotion) {
    this.financingPromotion = financingPromotion;
    return this;
  }

  /**
   * Some businesses offer special promotions when the goods or services sold are financed (i.e. this is a very common practice in the Motor industry). In such cases, this field indicates the discount in currency units.
   * @return financingPromotion
   */
  @javax.annotation.Nullable
  public String getFinancingPromotion() {
    return financingPromotion;
  }

  public void setFinancingPromotion(String financingPromotion) {
    this.financingPromotion = financingPromotion;
  }


  public LoanDetails productType(ProductTypeEnum productType) {
    this.productType = productType;
    return this;
  }

  /**
   * The desired financial product type (e.g. interest-free, interest-bearing, etc.)
   * @return productType
   */
  @javax.annotation.Nullable
  public ProductTypeEnum getProductType() {
    return productType;
  }

  public void setProductType(ProductTypeEnum productType) {
    this.productType = productType;
  }


  public LoanDetails openingFeePct(String openingFeePct) {
    this.openingFeePct = openingFeePct;
    return this;
  }

  /**
   * The desired maximum opening fee (expressed as a decimal)
   * @return openingFeePct
   */
  @javax.annotation.Nullable
  public String getOpeningFeePct() {
    return openingFeePct;
  }

  public void setOpeningFeePct(String openingFeePct) {
    this.openingFeePct = openingFeePct;
  }


  public LoanDetails maxNir(String maxNir) {
    this.maxNir = maxNir;
    return this;
  }

  /**
   * The desired maximum nominal interest rate (expressed as a decimal)
   * @return maxNir
   */
  @javax.annotation.Nullable
  public String getMaxNir() {
    return maxNir;
  }

  public void setMaxNir(String maxNir) {
    this.maxNir = maxNir;
  }


  public LoanDetails feePaymentType(FeePaymentTypeEnum feePaymentType) {
    this.feePaymentType = feePaymentType;
    return this;
  }

  /**
   * The preferred type of fee payment (if not zero)
   * @return feePaymentType
   */
  @javax.annotation.Nullable
  public FeePaymentTypeEnum getFeePaymentType() {
    return feePaymentType;
  }

  public void setFeePaymentType(FeePaymentTypeEnum feePaymentType) {
    this.feePaymentType = feePaymentType;
  }


  public LoanDetails gracePeriod(Integer gracePeriod) {
    this.gracePeriod = gracePeriod;
    return this;
  }

  /**
   * The desired grace period in months - initial period during which the loan doesn&#39;t have to be repaid
   * @return gracePeriod
   */
  @javax.annotation.Nullable
  public Integer getGracePeriod() {
    return gracePeriod;
  }

  public void setGracePeriod(Integer gracePeriod) {
    this.gracePeriod = gracePeriod;
  }


  public LoanDetails monthlyDueDate(Integer monthlyDueDate) {
    this.monthlyDueDate = monthlyDueDate;
    return this;
  }

  /**
   * The preferred date of the month on which the payment will be due (not every lender takes it into account)
   * @return monthlyDueDate
   */
  @javax.annotation.Nullable
  public Integer getMonthlyDueDate() {
    return monthlyDueDate;
  }

  public void setMonthlyDueDate(Integer monthlyDueDate) {
    this.monthlyDueDate = monthlyDueDate;
  }


  public LoanDetails insurance(Boolean insurance) {
    this.insurance = insurance;
    return this;
  }

  /**
   * Indicates whether preference should be given to offers that include (true) or don&#39;t include (false) an insurance
   * @return insurance
   */
  @javax.annotation.Nullable
  public Boolean getInsurance() {
    return insurance;
  }

  public void setInsurance(Boolean insurance) {
    this.insurance = insurance;
  }


  public LoanDetails noAccount(Boolean noAccount) {
    this.noAccount = noAccount;
    return this;
  }

  /**
   * If true, it indicates that the customer doesn&#39;t have the account number on hand (certain lenders are able to score applications without the account number, although it must be provided later if preapproved)
   * @return noAccount
   */
  @javax.annotation.Nullable
  public Boolean getNoAccount() {
    return noAccount;
  }

  public void setNoAccount(Boolean noAccount) {
    this.noAccount = noAccount;
  }


  public LoanDetails applicantType(ApplicantTypeEnum applicantType) {
    this.applicantType = applicantType;
    return this;
  }

  /**
   * It indicates whether the applicant is an individual or a company
   * @return applicantType
   */
  @javax.annotation.Nullable
  public ApplicantTypeEnum getApplicantType() {
    return applicantType;
  }

  public void setApplicantType(ApplicantTypeEnum applicantType) {
    this.applicantType = applicantType;
  }


  public LoanDetails maxMerchantCost(String maxMerchantCost) {
    this.maxMerchantCost = maxMerchantCost;
    return this;
  }

  /**
   * It indicates the maximum cost (in currency units) the merchant is willing to bear to subsidize loan interests
   * @return maxMerchantCost
   */
  @javax.annotation.Nullable
  public String getMaxMerchantCost() {
    return maxMerchantCost;
  }

  public void setMaxMerchantCost(String maxMerchantCost) {
    this.maxMerchantCost = maxMerchantCost;
  }


  public LoanDetails maxMerchantCostPct(String maxMerchantCostPct) {
    this.maxMerchantCostPct = maxMerchantCostPct;
    return this;
  }

  /**
   * It indicates the maximum cost (expressed as a decimal) the merchant is willing to bear to subsidize loan interests
   * @return maxMerchantCostPct
   */
  @javax.annotation.Nullable
  public String getMaxMerchantCostPct() {
    return maxMerchantCostPct;
  }

  public void setMaxMerchantCostPct(String maxMerchantCostPct) {
    this.maxMerchantCostPct = maxMerchantCostPct;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LoanDetails loanDetails = (LoanDetails) o;
    return Objects.equals(this.requestedAmount, loanDetails.requestedAmount) &&
        Objects.equals(this.maxMonthlyPayment, loanDetails.maxMonthlyPayment) &&
        Objects.equals(this.term, loanDetails.term) &&
        Objects.equals(this.financingPromotion, loanDetails.financingPromotion) &&
        Objects.equals(this.productType, loanDetails.productType) &&
        Objects.equals(this.openingFeePct, loanDetails.openingFeePct) &&
        Objects.equals(this.maxNir, loanDetails.maxNir) &&
        Objects.equals(this.feePaymentType, loanDetails.feePaymentType) &&
        Objects.equals(this.gracePeriod, loanDetails.gracePeriod) &&
        Objects.equals(this.monthlyDueDate, loanDetails.monthlyDueDate) &&
        Objects.equals(this.insurance, loanDetails.insurance) &&
        Objects.equals(this.noAccount, loanDetails.noAccount) &&
        Objects.equals(this.applicantType, loanDetails.applicantType) &&
        Objects.equals(this.maxMerchantCost, loanDetails.maxMerchantCost) &&
        Objects.equals(this.maxMerchantCostPct, loanDetails.maxMerchantCostPct);
  }

  @Override
  public int hashCode() {
    return Objects.hash(requestedAmount, maxMonthlyPayment, term, financingPromotion, productType, openingFeePct, maxNir, feePaymentType, gracePeriod, monthlyDueDate, insurance, noAccount, applicantType, maxMerchantCost, maxMerchantCostPct);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LoanDetails {\n");
    sb.append("    requestedAmount: ").append(toIndentedString(requestedAmount)).append("\n");
    sb.append("    maxMonthlyPayment: ").append(toIndentedString(maxMonthlyPayment)).append("\n");
    sb.append("    term: ").append(toIndentedString(term)).append("\n");
    sb.append("    financingPromotion: ").append(toIndentedString(financingPromotion)).append("\n");
    sb.append("    productType: ").append(toIndentedString(productType)).append("\n");
    sb.append("    openingFeePct: ").append(toIndentedString(openingFeePct)).append("\n");
    sb.append("    maxNir: ").append(toIndentedString(maxNir)).append("\n");
    sb.append("    feePaymentType: ").append(toIndentedString(feePaymentType)).append("\n");
    sb.append("    gracePeriod: ").append(toIndentedString(gracePeriod)).append("\n");
    sb.append("    monthlyDueDate: ").append(toIndentedString(monthlyDueDate)).append("\n");
    sb.append("    insurance: ").append(toIndentedString(insurance)).append("\n");
    sb.append("    noAccount: ").append(toIndentedString(noAccount)).append("\n");
    sb.append("    applicantType: ").append(toIndentedString(applicantType)).append("\n");
    sb.append("    maxMerchantCost: ").append(toIndentedString(maxMerchantCost)).append("\n");
    sb.append("    maxMerchantCostPct: ").append(toIndentedString(maxMerchantCostPct)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("requestedAmount");
    openapiFields.add("maxMonthlyPayment");
    openapiFields.add("term");
    openapiFields.add("financingPromotion");
    openapiFields.add("productType");
    openapiFields.add("openingFeePct");
    openapiFields.add("maxNir");
    openapiFields.add("feePaymentType");
    openapiFields.add("gracePeriod");
    openapiFields.add("monthlyDueDate");
    openapiFields.add("insurance");
    openapiFields.add("noAccount");
    openapiFields.add("applicantType");
    openapiFields.add("maxMerchantCost");
    openapiFields.add("maxMerchantCostPct");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to LoanDetails
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LoanDetails.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LoanDetails is not found in the empty JSON string", LoanDetails.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LoanDetails.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LoanDetails` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("requestedAmount") != null && !jsonObj.get("requestedAmount").isJsonNull()) && !jsonObj.get("requestedAmount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `requestedAmount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("requestedAmount").toString()));
      }
      if ((jsonObj.get("maxMonthlyPayment") != null && !jsonObj.get("maxMonthlyPayment").isJsonNull()) && !jsonObj.get("maxMonthlyPayment").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxMonthlyPayment` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxMonthlyPayment").toString()));
      }
      if ((jsonObj.get("financingPromotion") != null && !jsonObj.get("financingPromotion").isJsonNull()) && !jsonObj.get("financingPromotion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `financingPromotion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("financingPromotion").toString()));
      }
      if ((jsonObj.get("productType") != null && !jsonObj.get("productType").isJsonNull()) && !jsonObj.get("productType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `productType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("productType").toString()));
      }
      // validate the optional field `productType`
      if (jsonObj.get("productType") != null && !jsonObj.get("productType").isJsonNull()) {
        ProductTypeEnum.validateJsonElement(jsonObj.get("productType"));
      }
      if ((jsonObj.get("openingFeePct") != null && !jsonObj.get("openingFeePct").isJsonNull()) && !jsonObj.get("openingFeePct").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `openingFeePct` to be a primitive type in the JSON string but got `%s`", jsonObj.get("openingFeePct").toString()));
      }
      if ((jsonObj.get("maxNir") != null && !jsonObj.get("maxNir").isJsonNull()) && !jsonObj.get("maxNir").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxNir` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxNir").toString()));
      }
      if ((jsonObj.get("feePaymentType") != null && !jsonObj.get("feePaymentType").isJsonNull()) && !jsonObj.get("feePaymentType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `feePaymentType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("feePaymentType").toString()));
      }
      // validate the optional field `feePaymentType`
      if (jsonObj.get("feePaymentType") != null && !jsonObj.get("feePaymentType").isJsonNull()) {
        FeePaymentTypeEnum.validateJsonElement(jsonObj.get("feePaymentType"));
      }
      if ((jsonObj.get("applicantType") != null && !jsonObj.get("applicantType").isJsonNull()) && !jsonObj.get("applicantType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `applicantType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("applicantType").toString()));
      }
      // validate the optional field `applicantType`
      if (jsonObj.get("applicantType") != null && !jsonObj.get("applicantType").isJsonNull()) {
        ApplicantTypeEnum.validateJsonElement(jsonObj.get("applicantType"));
      }
      if ((jsonObj.get("maxMerchantCost") != null && !jsonObj.get("maxMerchantCost").isJsonNull()) && !jsonObj.get("maxMerchantCost").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxMerchantCost` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxMerchantCost").toString()));
      }
      if ((jsonObj.get("maxMerchantCostPct") != null && !jsonObj.get("maxMerchantCostPct").isJsonNull()) && !jsonObj.get("maxMerchantCostPct").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxMerchantCostPct` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxMerchantCostPct").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LoanDetails.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LoanDetails' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LoanDetails> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LoanDetails.class));

       return (TypeAdapter<T>) new TypeAdapter<LoanDetails>() {
           @Override
           public void write(JsonWriter out, LoanDetails value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LoanDetails read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of LoanDetails given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of LoanDetails
   * @throws IOException if the JSON string is invalid with respect to LoanDetails
   */
  public static LoanDetails fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LoanDetails.class);
  }

  /**
   * Convert an instance of LoanDetails to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

